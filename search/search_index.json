{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Osmboy's World!","title":"Welcome to Osmboy's World!"},{"location":"#welcome-to-osmboys-world","text":"","title":"Welcome to Osmboy's World!"},{"location":"about/","text":"Contact Me Email : rayoslei@gmail.com","title":"Contact Me"},{"location":"about/#contact-me","text":"Email : rayoslei@gmail.com","title":"Contact Me"},{"location":"algorithm/hackerrank/matrix_script/","text":"Matrix Script Matrix Script Problem Description Problem Solving Problem Description Neo has a complex matrix script . The matrix script is a N N X M M grid of strings. It consists of alphanumeric characters, spaces and symbols (!,@,#,$,%, ). To decode the script, Neo needs to read each column and select only the alphanumeric characters and connect them. Neo reads the column from top to bottom and starts reading from the leftmost column. If there are symbols or spaces between two alphanumeric characters of the decoded script, then Neo replaces them with a single space '' for better readability. Neo feels that there is no need to use ' if ' conditions for decoding. Alphanumeric characters consist of: [A-Z, a-z, and 0-9]. Input Format The first line contains space-separated integers N N (rows) and M M (columns) respectively. The next N N lines contain the row elements of the matrix script . Constraints 0 0 N N , M M 100 100 Note : A 0 0 score will be awarded for using ' if ' conditions in your code. Output Format Print the decoded matrix script . Sample Input 0 7 3 Tsi h%x i # sM $a #t% ir! Sample Output 0 This is Matrix# %! Explanation 0 The decoded script is: This$#is% Matrix# %! Neo replaces the symbols or spaces between two alphanumeric characters with a single space ' ' for better readability. So, the final decoded script is: This is Matrix# %! Problem Solving #!/bin/python import re first_multiple_input = raw_input () . rstrip () . split () n = int ( first_multiple_input [ 0 ]) m = int ( first_multiple_input [ 1 ]) matrix = [] md = . join ([ matrix [ i ][ j ] for j in range ( m ) for i in range ( n )]) md = re . sub ( r (? =[A-Za-z0-9])[\\!@#\\$% \\s]+(?=[A-Za-z0-9]) , , md ) print md","title":"Matrix Script"},{"location":"algorithm/hackerrank/matrix_script/#matrix-script","text":"Matrix Script Problem Description Problem Solving","title":"Matrix Script"},{"location":"algorithm/hackerrank/matrix_script/#problem-description","text":"Neo has a complex matrix script . The matrix script is a N N X M M grid of strings. It consists of alphanumeric characters, spaces and symbols (!,@,#,$,%, ). To decode the script, Neo needs to read each column and select only the alphanumeric characters and connect them. Neo reads the column from top to bottom and starts reading from the leftmost column. If there are symbols or spaces between two alphanumeric characters of the decoded script, then Neo replaces them with a single space '' for better readability. Neo feels that there is no need to use ' if ' conditions for decoding. Alphanumeric characters consist of: [A-Z, a-z, and 0-9]. Input Format The first line contains space-separated integers N N (rows) and M M (columns) respectively. The next N N lines contain the row elements of the matrix script . Constraints 0 0 N N , M M 100 100 Note : A 0 0 score will be awarded for using ' if ' conditions in your code. Output Format Print the decoded matrix script . Sample Input 0 7 3 Tsi h%x i # sM $a #t% ir! Sample Output 0 This is Matrix# %! Explanation 0 The decoded script is: This$#is% Matrix# %! Neo replaces the symbols or spaces between two alphanumeric characters with a single space ' ' for better readability. So, the final decoded script is: This is Matrix# %!","title":"Problem Description"},{"location":"algorithm/hackerrank/matrix_script/#problem-solving","text":"#!/bin/python import re first_multiple_input = raw_input () . rstrip () . split () n = int ( first_multiple_input [ 0 ]) m = int ( first_multiple_input [ 1 ]) matrix = [] md = . join ([ matrix [ i ][ j ] for j in range ( m ) for i in range ( n )]) md = re . sub ( r (? =[A-Za-z0-9])[\\!@#\\$% \\s]+(?=[A-Za-z0-9]) , , md ) print md","title":"Problem Solving"},{"location":"algorithm/hackerrank/morgan_and_a_string/","text":"Morgan and a String Morgan and a String 1\u3001Problem Description 2\u3001Problem solving 1\u3001Problem Description Jack and Daniel are friends. Both of them like letters, especially upper-case ones. They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack. Morgan wants to use all of the letters in their collections. As an example, assume Jack has collected a=[A,C,A] a=[A,C,A] and Daniel has b=[B,C,F] b=[B,C,F] . The example shows the top at index for each stack of letters. Assembling the string would go as follows: Jack Daniel result ACA BCF CA BCF A CA CF AB A CF ABC A CF ABCA F ABCAC ABCACF Note the choice when there was a tie at CA and CF . Function Description Complete the morganAndString function in the editor below. It should return the completed string. morganAndString has the following parameter(s): a : a string representing Jack's letters, top at index 0 b : a string representing Daniel's letters, top at index 0 Input Format The first line contains the an integer t , the number of test cases. The next t pairs of lines are as follows: - The first line contains string a - The second line contains string b . Constraints $ 1 = T =5$ 1 =|a|,|b| =10^{5} 1<=|a|,|b|<=10^{5} a and b contain upper-case letters only, ascii[A-Z] . Output Format Output the lexicographically minimal string result for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA Sample Output DAJACKNIEL AABABACABACABA Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string. 2\u3001Problem solving #!/bin/python import math import os import random import re import sys # Complete the morganAndString function below. def morganAndString ( a , b ): return . join ( morgan ( a , b )) def morgan ( a , b ): a += z b += z for _ in range ( len ( a ) + len ( b ) - 2 ): if a b : yield a [ 0 ] a = a [ 1 :] else : yield b [ 0 ] b = b [ 1 :] if __name__ == __main__ : fptr = open ( os . environ [ OUTPUT_PATH ], w ) t = int ( raw_input ()) for t_itr in xrange ( t ): a = raw_input () b = raw_input () result = morganAndString ( a , b ) fptr . write ( result + \\n ) fptr . close ()","title":"Morgan and a String"},{"location":"algorithm/hackerrank/morgan_and_a_string/#morgan-and-a-string","text":"Morgan and a String 1\u3001Problem Description 2\u3001Problem solving","title":"Morgan and a String"},{"location":"algorithm/hackerrank/morgan_and_a_string/#1problem-description","text":"Jack and Daniel are friends. Both of them like letters, especially upper-case ones. They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack. Morgan wants to use all of the letters in their collections. As an example, assume Jack has collected a=[A,C,A] a=[A,C,A] and Daniel has b=[B,C,F] b=[B,C,F] . The example shows the top at index for each stack of letters. Assembling the string would go as follows: Jack Daniel result ACA BCF CA BCF A CA CF AB A CF ABC A CF ABCA F ABCAC ABCACF Note the choice when there was a tie at CA and CF . Function Description Complete the morganAndString function in the editor below. It should return the completed string. morganAndString has the following parameter(s): a : a string representing Jack's letters, top at index 0 b : a string representing Daniel's letters, top at index 0 Input Format The first line contains the an integer t , the number of test cases. The next t pairs of lines are as follows: - The first line contains string a - The second line contains string b . Constraints $ 1 = T =5$ 1 =|a|,|b| =10^{5} 1<=|a|,|b|<=10^{5} a and b contain upper-case letters only, ascii[A-Z] . Output Format Output the lexicographically minimal string result for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA Sample Output DAJACKNIEL AABABACABACABA Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string.","title":"1\u3001Problem Description"},{"location":"algorithm/hackerrank/morgan_and_a_string/#2problem-solving","text":"#!/bin/python import math import os import random import re import sys # Complete the morganAndString function below. def morganAndString ( a , b ): return . join ( morgan ( a , b )) def morgan ( a , b ): a += z b += z for _ in range ( len ( a ) + len ( b ) - 2 ): if a b : yield a [ 0 ] a = a [ 1 :] else : yield b [ 0 ] b = b [ 1 :] if __name__ == __main__ : fptr = open ( os . environ [ OUTPUT_PATH ], w ) t = int ( raw_input ()) for t_itr in xrange ( t ): a = raw_input () b = raw_input () result = morganAndString ( a , b ) fptr . write ( result + \\n ) fptr . close ()","title":"2\u3001Problem solving"}]}