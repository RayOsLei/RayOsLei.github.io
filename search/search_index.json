{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Osmboy's World!","title":"Welcome to Osmboy's World!"},{"location":"#welcome-to-osmboys-world","text":"","title":"Welcome to Osmboy's World!"},{"location":"about/","text":"Contact Me Email : rayoslei@gmai.com","title":"Contact Me"},{"location":"about/#contact-me","text":"Email : rayoslei@gmai.com","title":"Contact Me"},{"location":"algorithm/hackerrank/morgan_and_a_string/","text":"Morgan and a String Morgan and a String 1\u3001Problem Description 2\u3001Problem solving 1\u3001Problem Description Jack and Daniel are friends. Both of them like letters, especially upper-case ones. They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack. Morgan wants to use all of the letters in their collections. As an example, assume Jack has collected a=[A,C,A] a=[A,C,A] and Daniel has b=[B,C,F] b=[B,C,F] . The example shows the top at index for each stack of letters. Assembling the string would go as follows: Jack Daniel result ACA BCF CA BCF A CA CF AB A CF ABC A CF ABCA F ABCAC ABCACF Note the choice when there was a tie at CA and CF . Function Description Complete the morganAndString function in the editor below. It should return the completed string. morganAndString has the following parameter(s): a : a string representing Jack's letters, top at index 0 b : a string representing Daniel's letters, top at index 0 Input Format The first line contains the an integer t , the number of test cases. The next t pairs of lines are as follows: - The first line contains string a - The second line contains string b . Constraints $ 1 = T =5$ 1 =|a|,|b| =10^{5} 1<=|a|,|b|<=10^{5} a and b contain upper-case letters only, ascii[A-Z] . Output Format Output the lexicographically minimal string result for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA Sample Output DAJACKNIEL AABABACABACABA Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string. 2\u3001Problem solving #!/bin/python import math import os import random import re import sys # Complete the morganAndString function below. def morganAndString ( a , b ): return . join ( morgan ( a , b )) def morgan ( a , b ): a += z b += z for _ in range ( len ( a ) + len ( b ) - 2 ): if a b : yield a [ 0 ] a = a [ 1 :] else : yield b [ 0 ] b = b [ 1 :] if __name__ == __main__ : fptr = open ( os . environ [ OUTPUT_PATH ], w ) t = int ( raw_input ()) for t_itr in xrange ( t ): a = raw_input () b = raw_input () result = morganAndString ( a , b ) fptr . write ( result + \\n ) fptr . close ()","title":"Morgan and a String"},{"location":"algorithm/hackerrank/morgan_and_a_string/#morgan-and-a-string","text":"Morgan and a String 1\u3001Problem Description 2\u3001Problem solving","title":"Morgan and a String"},{"location":"algorithm/hackerrank/morgan_and_a_string/#1problem-description","text":"Jack and Daniel are friends. Both of them like letters, especially upper-case ones. They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack. Morgan wants to use all of the letters in their collections. As an example, assume Jack has collected a=[A,C,A] a=[A,C,A] and Daniel has b=[B,C,F] b=[B,C,F] . The example shows the top at index for each stack of letters. Assembling the string would go as follows: Jack Daniel result ACA BCF CA BCF A CA CF AB A CF ABC A CF ABCA F ABCAC ABCACF Note the choice when there was a tie at CA and CF . Function Description Complete the morganAndString function in the editor below. It should return the completed string. morganAndString has the following parameter(s): a : a string representing Jack's letters, top at index 0 b : a string representing Daniel's letters, top at index 0 Input Format The first line contains the an integer t , the number of test cases. The next t pairs of lines are as follows: - The first line contains string a - The second line contains string b . Constraints $ 1 = T =5$ 1 =|a|,|b| =10^{5} 1<=|a|,|b|<=10^{5} a and b contain upper-case letters only, ascii[A-Z] . Output Format Output the lexicographically minimal string result for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA Sample Output DAJACKNIEL AABABACABACABA Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string.","title":"1\u3001Problem Description"},{"location":"algorithm/hackerrank/morgan_and_a_string/#2problem-solving","text":"#!/bin/python import math import os import random import re import sys # Complete the morganAndString function below. def morganAndString ( a , b ): return . join ( morgan ( a , b )) def morgan ( a , b ): a += z b += z for _ in range ( len ( a ) + len ( b ) - 2 ): if a b : yield a [ 0 ] a = a [ 1 :] else : yield b [ 0 ] b = b [ 1 :] if __name__ == __main__ : fptr = open ( os . environ [ OUTPUT_PATH ], w ) t = int ( raw_input ()) for t_itr in xrange ( t ): a = raw_input () b = raw_input () result = morganAndString ( a , b ) fptr . write ( result + \\n ) fptr . close ()","title":"2\u3001Problem solving"}]}